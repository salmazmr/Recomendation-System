# -*- coding: utf-8 -*-
"""Untitled14.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IEjMooh086OMB3qEScm6ihPqyQAqje6M

Salma Azmi Rasyidah/ M-05
"""

# Membuat folder .kaggle di dalam folder root
!rm -rf ~/.kaggle && mkdir ~/.kaggle/

# Menyalin berkas kaggle.json pada direktori aktif saat ini ke folder .kaggle
!mv kaggle.json ~/.kaggle/kaggle.json
!chmod 600 ~/.kaggle/kaggle.json

"""**A. Data Understanding**

Pertama, kita download dulu dataset dengan kode berikut.
"""

!kaggle datasets download -d shubhammehta21/movie-lens-small-latest-dataset

"""Jika berhasil, file movie-lens-small-latest-dataset.zip akan masuk ke sistem storage Google Colab. Kemudian, lakukan unzip file dengan menerapkan kode berikut."""

!unzip /content/movie-lens-small-latest-dataset.zip

"""1. Data Loading 

Selanjutnya, kita baca data-data di atas dengan menggunakan fungsi pandas.read_csv.
"""

import pandas as pd
 
movies = pd.read_csv('/content/movies.csv')
ratings = pd.read_csv('/content/ratings.csv')
ratings = ratings.drop(columns='timestamp')
 
print('Jumlah data film : ', len(movies.movieId.unique()))
print('Jumlah data penilaian dari users : ', len(ratings.userId.unique()))

"""2. Univariate Exploratory Data Analysis

Kita eksplorasi variabel-variabel yang ada pada dataset.

a. Movie variable
"""

movies.info()

"""Berdasarkan output di atas, kita dapat mengetahui bahwa **Movies.csv**, adalah file yang berisi informasi tentang film yang ada pada dataset. varibael yang terdapat pada file ini diantaranya movieId, title, dan genres. Dengan penjelasan masing-masing variabel sebagai berikut :

 - movieId : Id dari film 
 - title : Judul film
 - genres : Genre film

Selanjutnya kita lihat banyak data film serta jenis dari judul dan aliran. 
"""

print('Banyak data film: ', len(movies.movieId.unique()))
print('Jenis judul film : ', movies.title.unique())
print('Jenis aliran film : ', movies.genres.unique())

"""b. Ratings Variabel 

Selanjutnya kita eksplorasi file ratings.
"""

ratings.info()

"""**Ratings.csv**, adalah file yang berisi informasi tentang penilaian yang diberikan oleh pengguna. varibael yang terdapat pada file ini diantaranya movieId, userId, dan rating. Dengan penjelasan masing-masing variabel sebagai berikut :
 - movieId : Id dari film 
 - userId : Id dari pengguna
 - rating : Penilaian dari pengguna

 Selanjutnya kita akan mengetahui abnyak data user, penilaian, dan data film. 
"""

print('Banyak data user: ', len(ratings.userId.unique()))
print('Banyak penilaian : ', len(ratings.rating.unique()))
print('Banyak data film : ', len(ratings.movieId.unique()))

"""Didapat informasi bahwa :
Banyak data user:  610
Banyak penilaian :  10
Banyak data film :  9724

Kita lihat terlebih dahulu berapa jumlah kolom dan baris pada variabel ratings. 

"""

print(ratings.shape)

"""Selanjutnya, mari kita eksplorasi data yang akan kita gunakan pada model yaitu data rating. Pertama, kita lihat seperti apa data pada variabel rating dengan fungsi head()"""

ratings.head()

"""Kita dapat bahwa terdapat variabel userId, movieId, dan rating pada ratings. 

Nah, untuk melihat distribusi rating pada data, gunakan fungsi describe().
"""

ratings.describe()

"""Dari output di atas, diketahui bahwa nilai maksimum rating adalah 5 dan nilai minimumnya adalah 0.5. Artinya, skala rating berkisar antara 0.5 hingga 5. 

Selanjutnya, mari kita hitung jumlah rating dan userId berdasarkan movieId
"""

ratings.groupby('movieId').sum()

"""Lalu kita cek apakah ada missing value pada dataset."""

ratings.isnull().sum()

"""Karena tidak terdapat missing value kita bisa lanjut ke tahap berikutnya.

3. Data Preprocessing

Pertama, definisikan variabel all_movie_rate dengan variabel rating yang telah kita ketahui sebelumnya.


"""

all_movie_rate = ratings
all_movie_rate

"""Lalu kita gabungkan 'all_movie_rate' dengan dataframe yang berisi data dari file movies.csv."""

all_movie = pd.merge(all_movie_rate, movies[['movieId','title','genres']], how='left')
 

all_movie

"""B. Data Preparation

1. Mengatasi missing value

Lalu kita cek kembali apakah terdapat missing value pada dataframe yang baru saja kita buat. 
"""

all_movie.isnull().sum()

"""Karena tidak ada maka kita lanjut ke tahap berikutnya.

2. Menyamakan ID film 

Menyamakan ID film. 
Pertama, mari kita cek ulang data setelah proses cleaning pada tahap sebelumnya. Kita buat variabel baru bernama fix_movie untuk menyimpan dataframe.

"""

fix_movies = all_movie.sort_values('movieId', ascending=True)
fix_movies

"""Sekarang, kita memiliki 100836 baris data. Lalu mengecek berapa jumlah film yang mencakup data tersebut."""

len(fix_movies.movieId.unique())

"""Selanjutnya, mari kita cek genre film yang unik """

fix_movies.genres.unique()

"""Berikutnya, kita bisa melanjutkan ke tahap persiapan. Membuat variabel bernama preparation yang berisi dataframe fix_movie kemudian mengurutkan berdasarkan movieId."""

preparation = fix_movies
preparation.sort_values('movieId')

"""Selanjutnya, kita hanya akan menggunakan data unik untuk dimasukkan ke dalam proses pemodelan. Oleh karena itu, kita perlu menghapus data yang duplikat dengan fungsi drop_duplicates(). Dalam hal ini, kita membuang data duplikat pada kolom ‘movieId’."""

preparation = preparation.drop_duplicates('movieId')
preparation

"""3. Konversi Data Series Menjadi List

Selanjutnya, kita perlu melakukan konversi data series menjadi list. Dalam hal ini, kita menggunakan fungsi tolist() dari library numpy.
"""

movie_id = preparation['movieId'].tolist()
 

movie_title = preparation['title'].tolist()
 

movie_genres = preparation['genres'].tolist()
 
print(len(movie_id))
print(len(movie_title))
print(len(movie_genres))

"""Tahap berikutnya, kita akan membuat dictionary untuk menentukan pasangan key-value pada data movie_id, movie_title, dan movie_genres yang telah kita siapkan sebelumnya."""

movie_new = pd.DataFrame({
    'id': movie_id,
    'title': movie_title,
    'genres': movie_genres
})
movie_new

"""C. Modelling

a. Model Development - Content Based Filtering

Kini, saatnya Anda mengembangkan sistem rekomendasi dengan pendekatan content based filtering. Tapi sebelumnya, mari cek lagi data yang kita miliki dan assign dataframe dari tahap sebelumnya ke dalam variabel data
"""

data = movie_new
data.sample(5)

"""*   TF-IDF Vectorizer

Membangun sistem rekomendasi sederhana berdasarkan genre film. Teknik TF-IDF Vectorizer akan digunakan pada sistem rekomendasi untuk menemukan representasi fitur penting dari setiap genre film. Pada proyek ini, kita juga menggunakan fungsi tfidfvectorizer() dari library sklearn.
"""

from sklearn.feature_extraction.text import TfidfVectorizer

tf = TfidfVectorizer()

tf.fit(data['genres']) 
 

tf.get_feature_names()

"""Selanjutnya, lakukan fit dan transformasi ke dalam bentuk matriks. """

tfidf_matrix = tf.fit_transform(data['genres']) 

tfidf_matrix.shape

"""Matriks yang kita miliki berukuran (9724, 24). Nilai 9724 merupakan ukuran data dan 24 merupakan matrik kategori masakan.

Untuk menghasilkan vektor tf-idf dalam bentuk matriks, kita menggunakan fungsi todense().
"""

tfidf_matrix.todense()

"""Selanjutnya, mari kita lihat matriks tf-idf untuk beberapa film dan genrenya."""

pd.DataFrame(
    tfidf_matrix.todense(), 
    columns=tf.get_feature_names(),
    index=data.title
).sample(22, axis=1).sample(10, axis=0)

"""Output matriks tf-idf di atas menunjukkan Film Happy Go Lovely (1951) memiliki kategori musical. Begitu juga dengan yang lainnya.


*   Cosine Similarity

Selanjutnya, kita akan menghitung derajat kesamaan (similarity degree) antar film dengan teknik cosine similarity. Di sini, kita menggunakan fungsi cosine_similarity dari library sklearn. 
"""

from sklearn.metrics.pairwise import cosine_similarity
 
cosine_sim = cosine_similarity(tfidf_matrix) 
cosine_sim

"""Pada tahapan ini, kita menghitung cosine similarity dataframe tfidf_matrix yang kita peroleh pada tahapan sebelumnya. Dengan satu baris kode untuk memanggil fungsi cosine similarity dari library sklearn, kita telah berhasil menghitung kesamaan (similarity) antar film. Kode di atas menghasilkan keluaran berupa matriks kesamaan dalam bentuk array. 

Selanjutnya, mari kita lihat matriks kesamaan setiap film dengan menampilkan nama restoran dalam 5 sampel kolom (axis = 1) dan 10 sampel baris (axis=0). 
"""

cosine_sim_df = pd.DataFrame(cosine_sim, index=data['title'], columns=data['title'])
print('Shape:', cosine_sim_df.shape)
 

cosine_sim_df.sample(5, axis=1).sample(10, axis=0)

"""Dengan cosine similarity, kita berhasil mengidentifikasi kesamaan antara satu film dengan film lainnya. Shape (9724, 9724) merupakan ukuran matriks similarity dari data yang kita miliki. Berdasarkan data yang ada, matriks di atas sebenarnya berukuran 9724 film x 9724 film (masing-masing dalam sumbu X dan Y). Artinya, kita mengidentifikasi tingkat kesamaan pada 9724 nama film.



*   Mendapatkan Rekomendasi


Selanjutnya, kita membuat fungsi movie_recommendations dengan beberapa parameter sebagai berikut:

- Nama_film : Nama film (index kemiripan dataframe).
- Similarity_data : Dataframe mengenai similarity yang telah kita definisikan sebelumnya.
- Items : Nama dan fitur yang digunakan untuk mendefinisikan kemiripan, dalam hal ini adalah ‘movie_name’ dan ‘genres’.
- k : Banyak rekomendasi yang ingin diberikan.

Sistem rekomendasi menyatakan bahwa keluaran sistem ini adalah berupa top-N recommendation. Oleh karena itu, kita akan memberikan sejumlah rekomendasi film pada pengguna yang diatur dalam parameter k. 

"""

def movie_recommendations(nama_film, similarity_data=cosine_sim_df, items=data[['title', 'genres']], k=5):
    index = similarity_data.loc[:,nama_film].to_numpy().argpartition(
        range(-1, -k, -1))

    closest = similarity_data.columns[index[-1:-(k+2):-1]]
 
    closest = closest.drop(nama_film, errors='ignore')
 
    return pd.DataFrame(closest).merge(items).head(k)

"""Selanjutnya, mari kita terapkan kode di atas untuk menemukan rekomendasi film yang mirip dengan Father of the Bride Part II (1995)."""

data[data.title.eq('Father of the Bride Part II (1995)')]

"""Father of the Bride Part II (1995) masuk dalam kategori genre comedy. Tentu kita berharap rekomendasi yang diberikan adalah film dengan kategori yang mirip. """

movie_recommendations('Father of the Bride Part II (1995)')

"""Dapat dilihat dari hasil diatas sistem kita memberikan rekomendasi 5 judul film bergenre comedy. 

b. Model Development - Collaborative Filtering

* Data Understanding 

Pertama, jangan lupa import semua library yang dibutuhkan. 
"""

import pandas as pd
import numpy as np 
from zipfile import ZipFile
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
from pathlib import Path
import matplotlib.pyplot as plt

"""Untuk memudahkan supaya tidak tertukar dengan fitur ‘rating’ pada data, kita ubah nama variabel rating menjadi df."""

df = ratings
df

"""* Data Preparation

Pada tahap ini, melakukan persiapan data untuk menyandikan (encode) fitur ‘user’ dan ‘movieId’ ke dalam indeks integer
"""

user_ids = df['userId'].unique().tolist()
print('list userID: ', user_ids)
 
user_to_user_encoded = {x: i for i, x in enumerate(user_ids)}
print('encoded userID : ', user_to_user_encoded)
 
user_encoded_to_user = {i: x for i, x in enumerate(user_ids)}
print('encoded angka ke userID: ', user_encoded_to_user)

"""Selanjutnya, lakukan hal yang sama pada fitur ‘movieId’."""

movie_ids = df['movieId'].unique().tolist()
 

movie_to_movie_encoded = {x: i for i, x in enumerate(movie_ids)}
 

movie_encoded_to_movie = {i: x for i, x in enumerate(movie_ids)}

"""Berikutnya, petakan userId dan movieId ke dataframe yang berkaitan."""

df['user'] = df['userId'].map(user_to_user_encoded)
 

df['movie'] = df['movieId'].map(movie_to_movie_encoded)

"""Terakhir, cek beberapa hal dalam data seperti jumlah user, jumlah film, dan mengubah nilai rating menjadi float."""

num_users = len(user_to_user_encoded)
print(num_users)
 

num_movie = len(movie_to_movie_encoded)
print(num_movie)
 

df['rating'] = df['rating'].values.astype(np.float32)
 

min_rating = min(df['rating'])

max_rating = max(df['rating'])
 
print('Number of User: {}, Number of Movie: {}, Min Rating: {}, Max Rating: {}'.format(
    num_users, num_movie, min_rating, max_rating
))

"""Tahap persiapan telah selesai. 

* Membagi Data untuk Training dan Validasi 

Acak datanya terlebih dahulu agar distribusinya menjadi random.
"""

df = df.sample(frac=1, random_state=42)
df

"""Selanjutnya, kita bagi data train dan validasi dengan komposisi 80:20. Namun sebelumnya, kita perlu memetakan (mapping) data user dan film menjadi satu value terlebih dahulu. Lalu, buatlah rating dalam skala 0 sampai 1 agar mudah dalam melakukan proses training. """

x = df[['user', 'movie']].values
 

y = df['rating'].apply(lambda x: (x - min_rating) / (max_rating - min_rating)).values
 

train_indices = int(0.8 * df.shape[0])
x_train, x_val, y_train, y_val = (
    x[:train_indices],
    x[train_indices:],
    y[:train_indices],    
    y[train_indices:]
)
 
print(x, y)

"""* Proses Training

Di sini, kita membuat class RecommenderNet dengan keras Model class. Kode class RecommenderNet ini terinspirasi dari tutorial dalam situs Keras dengan beberapa adaptasi sesuai kasus yang sedang kita selesaikan.
"""

class RecommenderNet(tf.keras.Model):
 
  def __init__(self, num_users, num_movie, embedding_size, **kwargs):
    super(RecommenderNet, self).__init__(**kwargs)
    self.num_users = num_users
    self.num_movie = num_movie
    self.embedding_size = embedding_size
    self.user_embedding = layers.Embedding( # layer embedding user
        num_users,
        embedding_size,
        embeddings_initializer = 'he_normal',
        embeddings_regularizer = keras.regularizers.l2(1e-6)
    )
    self.user_bias = layers.Embedding(num_users, 1) # layer embedding user bias
    self.movie_embedding = layers.Embedding( # layer embeddings resto
        num_movie,
        embedding_size,
        embeddings_initializer = 'he_normal',
        embeddings_regularizer = keras.regularizers.l2(1e-6)
    )
    self.movie_bias = layers.Embedding(num_movie, 1) # layer embedding resto bias
 
  def call(self, inputs):
    user_vector = self.user_embedding(inputs[:,0]) # memanggil layer embedding 1
    user_bias = self.user_bias(inputs[:, 0]) # memanggil layer embedding 2
    resto_vector = self.movie_embedding(inputs[:, 1]) # memanggil layer embedding 3
    resto_bias = self.movie_bias(inputs[:, 1]) # memanggil layer embedding 4
 
    dot_user_movie = tf.tensordot(user_vector, resto_vector, 2) 
 
    x = dot_user_movie + user_bias + resto_bias
    
    return tf.nn.sigmoid(x) # activation sigmoid

"""Selanjutnya, lakukan proses compile terhadap model."""

model = RecommenderNet(num_users, num_movie, 50) # inisialisasi model
 
# model compile
model.compile(
    loss = tf.keras.losses.BinaryCrossentropy(),
    optimizer = keras.optimizers.Adam(learning_rate=0.001),
    metrics=[tf.keras.metrics.RootMeanSquaredError()]
)

"""Model ini menggunakan Binary Crossentropy untuk menghitung loss function, Adam (Adaptive Moment Estimation) sebagai optimizer, dan root mean squared error (RMSE) sebagai metrics evaluation. 

Langkah berikutnya, mulailah proses training. 
"""

history = model.fit(
    x = x_train,
    y = y_train,
    batch_size = 8,
    epochs = 100,
    validation_data = (x_val, y_val)
)

"""*Visualisasi Metrik

Untuk melihat visualisasi proses training, mari kita plot metrik evaluasi dengan matplotlib.
"""

plt.plot(history.history['root_mean_squared_error'])
plt.plot(history.history['val_root_mean_squared_error'])
plt.title('model_metrics')
plt.ylabel('root_mean_squared_error')
plt.xlabel('epoch')
plt.legend(['train', 'test'], loc='upper left')
plt.show()

"""Perhatikanlah, proses training model cukup smooth dan model konvergen pada epochs sekitar 100. Dari proses ini, kita memperoleh nilai error akhir sebesar sekitar 0.1763 dan error pada data validasi sebesar 0.2038. Nilai tersebut cukup bagus untuk sistem rekomendasi.

* Mendapatkan rekomendasi film

Sebelumnya, pengguna telah memberi rating pada beberapa film yang telah mereka tonton. Kita menggunakan rating ini untuk membuat rekomendasi film yang mungkin cocok untuk pengguna. Nah, film yang akan direkomendasikan tentulah film yang belum pernah tonton oleh pengguna. Oleh karena itu, kita perlu membuat variabel resto_not_visited sebagai daftar film untuk direkomendasikan pada pengguna. 

Variabel movie_not_visited diperoleh dengan menggunakan operator bitwise (~) pada variabel movie_visited_by_user.
"""

movie_df = movie_new
df = pd.read_csv('ratings.csv')
 
# Mengambil sample user
user_id = df.userId.sample(1).iloc[0]
movie_visited_by_user = df[df.userId == user_id]
 
# Operator bitwise (~), bisa diketahui di sini https://docs.python.org/3/reference/expressions.html 
movie_not_visited = movie_df[~movie_df['id'].isin(movie_visited_by_user.movieId.values)]['id'] 
movie_not_visited = list(
    set(movie_not_visited)
    .intersection(set(movie_to_movie_encoded.keys()))
)
movie_not_visited = [[movie_to_movie_encoded.get(x)] for x in movie_not_visited]
user_encoder = user_to_user_encoded.get(user_id)
user_movie_array = np.hstack(
    ([[user_encoder]] * len(movie_not_visited), movie_not_visited)
)

"""Selanjutnya, untuk memperoleh rekomendasi film, gunakan fungsi model.predict() dari library Keras dengan menerapkan kode berikut."""

ratings = model.predict(user_movie_array).flatten()
 
top_ratings_indices = ratings.argsort()[-10:][::-1]
recommended_movie_ids = [
    movie_encoded_to_movie.get(movie_not_visited[x][0]) for x in top_ratings_indices
]
 
print('Showing recommendations for users: {}'.format(user_id))
print('===' * 9)
print('Movie with high ratings from user')
print('----' * 8)
top_movie_user = (
    movie_visited_by_user.sort_values(
        by = 'rating',
        ascending=False
    )
    .head(5)
    .movieId.values
)
 
movie_df_rows = movie_df[movie_df['id'].isin(top_movie_user)]
for row in movie_df_rows.itertuples():
    print(row.title, ':', row.genres)
print('----' * 8)
print('Top 10 movie recommendation')
print('----' * 8)
 
recommended_movie = movie_df[movie_df['id'].isin(recommended_movie_ids)]
for row in recommended_movie.itertuples():
    print(row.title, ':', row.genres)

"""Sebagai contoh, hasil di atas adalah rekomendasi untuk user dengan id 464. Dari output tersebut, kita dapat membandingkan antara film with high ratings from user dan Top 10 film recommendation untuk user. 

Perhatikanlah, beberapa memiliki genre yang sesuai dengan rating user. Dan rekomendasi 10 film diantaranya :
- Heidi Fleiss: Hollywood Madam (1995) : Documentary
- Paths of Glory (1957) : Drama|War
- Jonah Who Will Be 25 in the Year 2000 (Jonas qui aura 25 ans en l'an 2000) (1976) : Comedy
- Stunt Man, The (1980) : Action|Adventure|Comedy|Drama|Romance|Thriller
- Belle époque (1992) : Comedy|Romance
- Trial, The (Procès, Le) (1962) : Drama
- Adam's Rib (1949) : Comedy|Romance
- Enter the Void (2009) : Drama
- Bill Hicks: Revelations (1993) : Comedy
- Band of Brothers (2001) : Action|Drama|War
"""